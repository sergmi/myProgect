function BinarySearchTree(){
	this._root=null;
}

BinarySearchTree.prototype={				//объявляю методы для объектов класса BinarySearchTree, т.е. все новые объекты класса BinarySearchTree будут иметь прототип {...}
	constructor: BinarySearchTree,			//свойство constructor должно указывать на саму функцию

	//метод добавления элемента к дереву
	add: function (val){
			var node = {                 //создаю элемент, содержащий свойство value со значением параметра функции val
                value: val,
                left: null,
                right: null
			},
			current;
		
		if (this._root === null){		//проверяю если корень дерева пустой
            this._root = node;				//то созданный элемент становится корнем дерева
        } else {						//иначе т.к. существует корень дерева
            current = this._root;			//переменная current равна корню
			while(true){          				//цикл повторяется пока значения переменных истинны     		
                if (val < current.value){			//если значение val созданного элемента меньше значения value переменной current
                    if (current.left === null){			//и если левый лист переменной current пустой (не существует)
                        current.left = node;			//то левым листом переменной current становится созданный элемент				
						break;							//прерывание цикла
                    } else {						//иначе значит существует левый лист переменной current и 
						current = current.left;			//тогда переменная current становится равна своему левому листу
                    }
                } else if (val > current.value){	//если значение val созданного элемента больше значения value переменной current
                    if (current.right === null){		//и если правый лист переменной current пустой (не существует)
                        current.right = node;			//то правым листом переменной current становится созданный элемент
                        break;							//прерывание цикла
                    } else {						//иначе значит существует правый лист переменной current и
                        current = current.right;		//тогда переменная current становится равна своему правому листу
                    }
                } else {							//иначе
                    break;							//созданный элемент равен уже существующему элементу дерева, прерывание цикла
                }
			}
		}
	},
	//метод проверки нахождения элемента в дереве
	contains: function (val){
		var found=false,			
		current=this._root;							//переменной current присваивается значение корня, т.е. проверку начнем с корня дерева
			
		while(!found&&current){				//цикл повторяется пока элемент не найдется или он отсутствует в дереве
			if(val<current.value){				//если значение val искомого элемента меньше значения value переменной current
				current=current.left;				//тогда переменная current становится равна своему левому листу
			}
			else if (val>current.value){		//если значение val искомого элемента больше значения value переменной current
				current=current.right;				//тогда переменная current становится равна своему правому листу
			}
			else {								//иначе значение val искомого элемента равно значению value переменной current
				found=true;							//элемент найден, прерывание цикла
			}
		}		
		return found;						//если элемент найден в дереве, то в found возвращается истина, если не найден - ложь
	},
	
	//метод обхода по дереву
	traverse: function (process){
         function inOrder(nod){                         //функция симметричного обхода дерева
//			console.log('nod= ',nod);
            if (nod){										//если существует элемент дерева, то

                if (nod.left !== null){							//если левый лист элемента не пустой, то
                    inOrder(nod.left);							//выполняю обход левой ветви
                }            
			
                process.call(this, nod);				//вызываю функцию, переданную ранее параметром (process) в значении свойства traverse

                if (nod.right !== null){						//если правый лист элемента не пустой, то
                    inOrder(nod.right);							//выполняю обход правой ветви
                }
            }
        }
        inOrder.call(this, this._root);                   //вызов функции симметричного обхода дерева, начиная с корня
    },
	
	//метод, определяющий количество элементов в дереве
	size: function(){
        var length = 0;

        this.traverse(function(node){			//вызываю метод обхода дерева с параметром в виде функции, считающей элементы
            length++;
        });
//		console.log('length= ',length);
        return length;
    },
	
	//метод, преобразующий дерево в массив
	toArray: function(){
        var result = [];

        this.traverse(function(node){			//вызываю метод обхода дерева с параметром в виде функции, 
            result.push(node.value);			//записывающей значения элементов дерева в массив
        });
//		console.log('result= ',result);
        return result;
    },

	//метод, преобразующий дерево в массив, а затем в строчное представление данных
    toSSString: function(){
//		console.log('this.toArray().toString()= ',this.toArray().toString());
        return this.toArray().toString();
    },

	//метод, удаляющий элемент из дерева	
	remove: function(value){				//value - значение параметра функции; элемент с этим значением д.б. удален

        var found       = false,
            parent      = null,
            current     = this._root,		//переменной current присваиваю корень дерева
            childCount,
            replacement,
            replacementParent;

        while(!found && current){			//цикл повторяется пока элемент не найдется или он отсутствует в дереве

            if (value < current.value){		//если искомое значение меньше значения переменной current (т.е. меньше значения текущего элемента), то
                parent = current;				//переменной parent присваиваю переменную current (присваиваю текущий элемент)
                current = current.left;			//переменной current присваиваю элемент, находящийся слева от нее (левый лист)

            } else if (value > current.value){		//если искомое значение больше значения переменной current (т.е. больше значения текущего элемента), то
                parent = current;						//переменной parent присваиваю переменную current (присваиваю текущий элемент)
                current = current.right;				//переменной current присваиваю элемент, находящийся справа от нее (правый лист)

            } else {								//искомое значение равно значению переменной current (т.е. равно значению текущего элемента)
                found = true;						//элемент найден, прерывание цикла
            }
        }

        if (found){												//если искомый элемент найден
																	//считаю количество отходящих элементов (листов) от текущего элемента
            childCount = (current.left !== null ? 1 : 0) + 			//если сравнение истинно, т.е. существует у текущего левый отходящий элемент, то возвращается из выражения 1
                         (current.right !== null ? 1 : 0);			//если сравнение ложно, т.е. не существует у текущего левый отходящий элемент, то возвращается из выражения 0
																	//аналогично для правого
						 
            if (current === this._root){			//если текущий элемент - это корень
                switch(childCount){						//выполняю номер контейнера, соответствующий количеству отходящих элементов (листов)

                    case 0:										//нет отходящих элементов (листов)
                        this._root = null;							//корень очищаю
                        break;

                    case 1:										//один отходящий элемент (лист)
                        this._root = (current.right === null ? 		//корню присваиваю значение отходящего элемента (листа), который определяется после сравнения правого элемента с null
                                      current.left : current.right);
                        break;

                    case 2:										//два отходящих элемента (листа)
                        replacement = this._root.left;				//переменной replacement присваиваю левый от корня элемент

                        while (replacement.right !== null){			//цикл нахождения элемента с самым большим значением и присвоение переменной replacement этого элемента
                            replacementParent = replacement;
                            replacement = replacement.right;
                        }

                        if (replacementParent !== null){			//если родитель элемента, находящегося в переменной	replacement не пустой, то

                            replacementParent.right = replacement.left;	//отходящему справа от родителя элементу присваивается левый элемент, отходящий от самого большого

                            replacement.right = this._root.right;		//отходящему справа от самого большого элемента присваивается элемент, отходящий справа от корня
                            replacement.left = this._root.left;			//отходящему слева от самого большого элемента присваивается элемент, отходящий слева от корня
                        } else {									//иначе

                            replacement.right = this._root.right;		//отходящему справа от самого большого элемента присваивается элемент, отходящий справа от корня
                        }

                        this._root = replacement;						//корню присваивается найденный самый большой элемент
                }        
														
            } else {											//текущий элемент - это не корень

                switch (childCount){								//выполняю номер контейнера, соответствующий количеству отходящих элементов (листов)

                    case 0:												//нет отходящих элементов (листов)

                        if (current.value < parent.value){					//если значение текущего элемента меньше значения родителя, то 
                            parent.left = null;									//очищаю левый отходящий от родителя элемент

                        } else {											//иначе
                            parent.right = null;								//очищаю правый отходящий от родителя элемент
                        }
                        break;

                    case 1:												//один отходящий элемент (лист) от текущего

                        if (current.value < parent.value){					//если значение текущего элемента меньше значения родителя, то
                            parent.left = (current.left === null ? 				//левому отходящему от родителя элементу присваиваю существующий отходящий элемент (лист) от текущего
                                           current.right : current.left);


                        } else {											//иначе т.к. значение текущего элемента больше значения родителя, то
                            parent.right = (current.right === null ? 			//правому отходящему от родителя элементу присваиваю существующий отходящий элемент (лист) от текущего
                                            current.right : current.left);
                        }
                        break;    

                    case 2:												//два отходящих элемента (листа) от текущего

                        replacement = current.left;					//переменной replacement присваивается левый от текущего элемент
                        replacementParent = current;				//переменной replacementParent присваивается текущий элемент

                        while(replacement.right !== null){			//цикл нахождения элемента с самым большим значением и присвоение переменной replacement этого элемента
                            replacementParent = replacement;
                            replacement = replacement.right;
                        }

                        replacementParent.right = replacement.left;	//отходящему справа от родителя элементу присваивается левый элемент, отходящий от самого большого

                        replacement.right = current.right;			//отходящему справа от самого большого элемента присваивается элемент, отходящий справа от текущего
                        replacement.left = current.left;			//отходящему слева от самого большого элемента присваивается элемент, отходящий слева от текущего

                        if (current.value < parent.value){			//если значение текущего элемента меньше значения родителя, то
                            parent.left = replacement;					//отходящему слева от родителя присваивается найденный самый большой элемент
                        } else {									//иначе
                            parent.right = replacement;					//отходящему справа от родителя присваивается найденный самый большой элемент
                        }          

                }

            }
        
        }

    }
		
}


var BST= new BinarySearchTree();			//создаю новый объект класса BinarySearchTree со ссылкой на прототип BinarySearchTree.prototype

BST.add(20);								//добавляю в дерево элемент со значением 20
BST.add(10);								//добавляю в дерево элемент со значением 10
BST.add(30);								//добавляю в дерево элемент со значением 30
BST.add(15);								//добавляю в дерево элемент со значением 15
BST.add(6);									//добавляю в дерево элемент со значением 6
BST.add(4);									//добавляю в дерево элемент со значением 4
BST.add(8);									//добавляю в дерево элемент со значением 8
BST.add(17);								//добавляю в дерево элемент со значением 17
BST.add(12);								//добавляю в дерево элемент со значением 20

BST.contains(44);							//проверяю наличие в дереве элемента со значением 44

BST.size();									//узнаю количество элементов в дереве

BST.toArray();								//преобразую значения элементов дерева в массив

BST.toSSString();							//преобразую значения элементов дерева к строчному представлению

BST.remove(10);								//удаляю из дерева элемент со значением 10

BST.size();									//узнаю количество элементов в дереве

BST.toArray();								//преобразую значения элементов дерева в массив